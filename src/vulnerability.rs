use std::collections::BTreeMap;
use std::fmt::{Display, Formatter};
use neo4rs::{Graph, query};
use crate::format::trivy::TrivyJson;

#[derive(Debug, Clone)]
pub struct Vulnerability {
    id: String,
    source: VulnSource,
    os: Os,
}

#[derive(Debug, Clone)]
struct Os {
    family: String,
    version: String,
}

#[derive(Debug, Clone)]
pub enum VulnSource {
    DockerImage(DockerImage),
}

async fn insert(graph: &Graph, vuln: &Vulnerability) {
    let query_str = r"MERGE (v:Vuln{id: $id})
                              MERGE (os:Os{family: $family, version: $version})
                              MERGE (img:DockerImage{id: $img_id, entrypoint: $entrypoint, env: $env})
                              MERGE (v)-[:VULNERABLE_ON]->(os)
                              MERGE (img)-[:AFFECTED_BY]->(v)
                              RETURN v, os, img";
    let Vulnerability {
        id,
        os: Os { family, version },
        source: VulnSource::DockerImage(
            DockerImage {
                name,
                entrypoint,
                env,
            },
        ),
    } = vuln.clone();

    let query = query(query_str)
        .param("id", id)
        .param("family", family)
        .param("version", version)
        .param("img_id", name)
        .param("entrypoint", entrypoint.join(" "))
        .param("env", env.iter().map(|(k, v)| format!("{}={}", k, v)).collect::<Vec<_>>().join(" "));

    graph.run(query).await.unwrap();
}

impl Display for EnvValue {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            EnvValue::Single(v) => write!(f, "{}", v),
            EnvValue::Multiple(vals) => write!(f, "{}", vals.join(":")),
        }
    }
}

#[derive(Debug, Clone)]
pub enum EnvValue {
    Single(String),
    Multiple(Vec<String>),
}

#[derive(Debug, Clone)]
pub struct DockerImage {
    name: String,
    entrypoint: Vec<String>,
    env: BTreeMap<String, EnvValue>,
}

impl Vulnerability {
    pub fn from_trivy(file: &TrivyJson) -> Self {
        Self {
            id: file.metadata.image_id.clone(),
            source: VulnSource::DockerImage(DockerImage::from_trivy(file)),
            os: Os::from_trivy(file),
        }
    }
}

impl DockerImage {
    pub fn from_trivy(file: &TrivyJson) -> Self {
        let envs = &file.metadata.image_config.config.env;
        let envs = BTreeMap::from_iter(envs.iter().map(|v| {
            let vals = v.split('=').collect::<Vec<_>>();
            if vals.len() != 2 {
                panic!("Issue with envs");
            }
            let key = vals[0];
            let val = vals[1];
            let vals = val.split(':').collect::<Vec<_>>();
            (key.to_string(), if vals.len() == 1 {
                EnvValue::Single(vals[0].to_string())
            } else {
                EnvValue::Multiple(vals.iter().map(|v| v.to_string()).collect::<Vec<_>>())
            })
        }));

        Self {
            name: file.metadata.image_id.clone(),
            env: envs,
            entrypoint: file.metadata.image_config.config.entrypoint.clone(),
        }
    }
}

impl Os {
    pub fn from_trivy(trivy: &TrivyJson) -> Self {
        Self {
            family: trivy.metadata.os.family.clone(),
            version: trivy.metadata.os.name.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::fs::File;
    use std::io::BufReader;
    use crate::format::trivy::TrivyJson;
    use crate::vulnerability::Vulnerability;

    #[test]
    fn read_file_works() {
        let trivy = File::open("cache/molkars/pbd/1.0/trivy.json").unwrap();
        let reader = BufReader::new(trivy);
        let _: TrivyJson = serde_json::from_reader(reader).unwrap();
    }

    #[tokio::test]
    async fn test_insert() {
        let graph = crate::establish_graph().await;
        let vuln = TrivyJson::from_file("cache/molkars/pbd/1.0/trivy.json").unwrap();
        let vuln = Vulnerability::from_trivy(&vuln);
        crate::vulnerability::insert(&graph, &vuln).await;
    }
}